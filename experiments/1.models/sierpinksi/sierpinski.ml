open Util.Misc

(* let ang = pi /. 3. *)
(* let rot = {C.re = cos ang; C.im = sin ang} *)
(* let hexagon = [| *)
(*   c1; *)
(*   rot; *)
(*   rot *& rot; *)
(*   rot *& rot *& rot; *)
(*   rot *& rot *& rot *& rot; *)
(*   rot *& rot *& rot *& rot *& rot; |] *)

(* let _ = *)
(*   let gram = Abstract.new_live_grammar () in *)

(*   let top_sdata = { *)
(*     closed = true; *)
(*     straightprob = 0.; *)
(*     straightcost = infinity; *)
(*     curve = hexagon} *)
(*   in *)
(*   let mid_sdata = { *)
(*     closed = false; *)
(*     straightprob = 0.; *)
(*     straightcost = infinity; *)
(*     curve = hexagon} *)
(*   in *)
(*   let bot_sdata = { *)
(*     closed = false; *)
(*     straightprob = 1.; *)
(*     straightcost = 0.; *)
(*     curve = hexagon} *)
(*   in *)

(*   let _ = *)
(*     Abstract.make_new_symbol gram top_sdata true *)
(*   in *)
    

(*   let a_to_cb = Watson  *)
(*     Watson.watson_distro_family.Distro.build  *)
(*     {Watson.mean_shape = Shape.shape_of_complex_bme hexagon.(3) hexagon.(1) hexagon.(0); *)
(*      Watson.concentration = 1000.;}     *)
(*   in *)
(*   let c_to_ba =  *)
(*     Watson.watson_distro_family.Distro.build  *)
(*       {Watson.mean_shape = Shape.shape_of_complex_bme hexagon.(3) hexagon.(2) hexagon.(1); *)
(*        Watson.concentration = 1000.;}     *)
(*   in *)
(*   let b_to_da =  *)
(*     Watson.watson_distro_family.Distro.build  *)
(*       {Watson.mean_shape = Shape.shape_of_complex_bme hexagon.(3) hexagon.(5) hexagon.(0); *)
(*        Watson.concentration = 1000.;}     *)
(*   in *)
(*   let d_to_ab = *)
(*     Watson.watson_distro_family.Distro.build  *)
(*       {Watson.mean_shape = Shape.shape_of_complex_bme hexagon.(3) hexagon.(4) hexagon.(5); *)
(*        Watson.concentration = 1000.;}     *)
(*   in *)

(*     for i = 1 to nlvls-1 do *)
(*       let asym = Abstract.make_new_symbol gram mid_sdata false in *)
(*       let bsym = Abstract.make_new_symbol gram mid_sdata false in *)
(*       let csym = Abstract.make_new_symbol gram mid_sdata false in *)
(*       let dsym = Abstract.make_new_symbol gram mid_sdata false in *)

(* 	Abstract.imake_new_composition gram asym.sid (csym.sid,bsym.sid) *)
(* 	  { prob = p; *)
(* 	    cost = -. log p; *)
(* 	    geom = a_to_cb; *)
(* 	    lcurve = hexagon; *)
(* 	    rcurve = hexagon; *)
(* 	    ocurve = hexagon; *)
(* 	  }; *)
(* 	Abstract.imake_new_composition gram csym.sid (bsym.sid,asym.sid) *)
(* 	  { prob = p; *)
(* 	    cost = -. log p; *)
(* 	    geom = a_to_cb; *)
(* 	    lcurve = hexagon; *)
(* 	    rcurve = hexagon; *)
(* 	    ocurve = hexagon; *)
(* 	  }; *)
(* 	Abstract.imake_new_composition gram asym.sid (csym.sid,bsym.sid) *)
(* 	  { prob = p; *)
(* 	    cost = -. log p; *)
(* 	    geom = a_to_cb; *)
(* 	    lcurve = hexagon; *)
(* 	    rcurve = hexagon; *)
(* 	    ocurve = hexagon; *)
(* 	  }; *)
(* 	Abstract.imake_new_composition gram asym.sid (csym.sid,bsym.sid) *)
(* 	  { prob = p; *)
(* 	    cost = -. log p; *)
(* 	    geom = a_to_cb; *)
(* 	    lcurve = hexagon; *)
(* 	    rcurve = hexagon; *)
(* 	    ocurve = hexagon; *)
(* 	  }; *)
(*     done; *)
